" Created:  Tue 12 Aug 2014
" Modified: Fri 30 Jan 2015
" Author:   Josh Wainwright
" Filename: vimrc

" Paths and Variables            {{{1
"

if has('unix')
	let $VIMHOME=$HOME.'/.vim/'
elseif has('win32')
	let $VIMHOME=$HOME.'/vimfiles/'
	let $PATH=$PATH.';C:/cygwin/bin/'
endif

" Vim-Plug Plugins               {{{1
"

let g:plug_threads = 6
let g:plug_timeout = 20

if executable('git')
	call plug#begin($VIMHOME.'plugged')

	" Appearance Utilities       {{{2
	Plug 'ap/vim-buftabline'

	" Git Related                {{{2

	"Git management from withing vim
	Plug 'tpope/vim-fugitive'
	"Gitk for vim
	Plug 'gregsexton/gitv', {'on': 'Gitv'}

	" Other                      {{{2

	if has('python')
		"Snippet management
		Plug 'SirVer/ultisnips', {'on' : 'UltiSnipsLoad'}
		Plug 'honza/vim-snippets', {'on' : 'UltiSnipsLoad'}
		command! UltiSnipsLoad :
	endif
	if !has('win32unix')
		"Syntax checking for a wide range of languages
		Plug 'scrooloose/syntastic'
	end
	"Closing of brackets, tags, quotes etc.
	Plug 'Raimondi/delimitMate'
	"Easy commenting/uncommenting of code.
	Plug 'tpope/vim-commentary'
	"Simple alignment of lines
	Plug 'tommcdo/vim-lion'
	"Multiple useful keybindings
	Plug 'tpope/vim-unimpaired'
	"Simple minimalist alternative to netrw
	Plug 'jeetsukumaran/vim-filebeagle'
	"Allow incrementing true/false values etc.
	Plug 'nishigori/increment-activator'
	"Make f (forward) and t (to) better
	Plug 'clever-f.vim'
	"Rename multiple files using vim
	Plug 'vim-scripts/renamer.vim', {'on' : 'Renamer' }
	Plug 'pelodelfuego/vim-swoop'

	" Filetype specific          {{{2

	"Override detection of .md files to markdown
	Plug 'tpope/vim-markdown', {'for': 'markdown'}
	"Decrypt, edit and then re-encrypt gpg stored files.
	Plug 'jamessan/vim-gnupg'

	if executable('vifm')
		Plug 'istib/vifm.vim'
	endif
	Plug 'Z1MM32M4N/vim-superman'

	" }}}
	call plug#end()
endif " executable(git)

" Plugin Settings                {{{1
"

filetype off

"""" UltiSnips Plugin
set runtimepath^=$HOME/.vim/custom
let g:UltiSnipsSnippetsDir         =  "~/.vim/custom/mysnippets"
let g:UltiSnipsSnippetDirectories  = ["UltiSnips","mysnippets"]
let g:UltiSnipsEditSplit           =  "vertical"
let g:UltiSnipsEnableSnipMate      =  0
let g:UltiSnipsExpandTrigger       = "<c-j>"
let g:UltiSnipsJumpForwardTrigger  = "<c-j>"
let g:UltiSnipsJumpBackwardTrigger = "<c-k>"

"""" Syntastic
let g:syntastic_check_on_wq              = 0
let g:syntastic_auto_loc_list            = 0
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_tex_checkers             = ['chktex']

"""" Molokai Theme
let g:molokai_original = 1

""" VimCompletesMe
let g:vcm_direction = 'n'

""" Supertab
"let g:SuperTabCrMapping = 0 "Needed to allow delimitMate_expand_cr
"let g:SuperTabDefaultCompletionType = "context"
"let g:SuperTabContextDefaultCompletionType = "<c-n>"

"""" delimitMate
let delimitMate_jump_expansion = 0
let delimitMate_expand_cr      = 2
let delimitMate_expand_space   = 1

""" Clever F
let g:clever_f_smart_case        = 1
let g:clever_f_mark_cursor       = 1
let g:clever_f_mark_cursor_color = 'Error'

""" WhiteSpace
if $USERNAME == 'JoshWainwright'
	let g:noStripWhitespace = 1
endif

""" BufTabLine
let g:buftabline_show       = 1
let g:buftabline_numbers    = 1
let g:buftabline_indicators = 1

" Functions                      {{{1
"

" MyFoldText {{{2
"

function! MyFoldText()
	let line = getline(v:foldstart)

	let nucolwidth = &fdc + &number * &numberwidth
	let windowwidth = winwidth(0) - nucolwidth - 3
	let foldedlinecount = v:foldend - v:foldstart

	" expand tabs into spaces
	let onetab = strpart('          ', 0, &tabstop)
	let line = substitute(line, '\t', onetab, 'g')

	let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
	let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
	return line . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction " }}}

" Verbose {{{2
"
command! -range=999998 -nargs=1 -complete=command Verbose
      \ :exe s:Verbose(<count> == 999998 ? '' : <count>, <q-args>)

function! s:Verbose(level, excmd)
  let temp = tempname()
  let verbosefile = &verbosefile
  call writefile([':'.a:level.'Verbose '.a:excmd], temp, 'b')
  return
        \ 'try|' .
        \ 'let &verbosefile = '.string(temp).'|' .
        \ 'silent '.a:level.'verbose exe '.string(a:excmd).'|' .
        \ 'finally|' .
        \ 'let &verbosefile = '.string(verbosefile).'|' .
        \ 'endtry|' .
        \ 'pedit '.temp.'|wincmd P|nnoremap <buffer> q :bd<CR>'
endfunction " }}}

" Oldfiles {{{2
"
function! s:Oldfiles()
	Verbose oldfiles
	0d
	silent %s/\v\d+: //
	setlocal nobuflisted
	setlocal buftype=nofile
	setlocal bufhidden=delete
	setlocal noswapfile
	setlocal nomodifiable
	norm gg
endfunction
command! Oldfiles :call s:Oldfiles()

" Settings                       {{{1
"

filetype plugin on
filetype indent on
syntax on
colorscheme molokaiV
set encoding=utf-8 " character encoding used in Vim: "latin1", "utf-8"

" 1 important {{{2

" 2 moving around, searching and patterns {{{2
set whichwrap+=<,>,h,l " list of flags specifying which commands wrap to another line
set nostartofline      " many jump commands move the cursor to the first non-blank
"set path+=../**        " list of directory names used for file searching
set incsearch          " show match for partly typed search command
set magic              " change the way backslashes are used in search patterns
set ignorecase         " ignore case when using a search pattern
set smartcase          " override 'ignorecase' when pattern has upper case characters

" 4 displaying text {{{2

" 3 tags {{{2
set scrolloff=5      " minimal number of columns to keep left and right of the cursor
set wrap             " margin from the right in which to break a line
set linebreak        " wrap long lines at a character in 'breakat'
set fillchars=vert:â”‚ " characters to use for the status line, folds and filler lines
set cmdheight=1      " number of lines used for the command-line
set lazyredraw       " don't redraw while executing macros
set list             " show <Tab> as ^I and end-of-line as $
set listchars=tab:Â·\ ,trail:â–¸,nbsp:#,extends:Â»,precedes:Â« " list of strings used for list mode
augroup trailing " {{{
	au!
	au InsertEnter * :set listchars-=trail:â–¸
	au InsertLeave * :set listchars+=trail:â–¸
augroup END " }}}
"set lcs=tab:â–¸\ ,trail:Â·,eol:Â¬,nbsp:_
set number                 " show the line number for each line
silent! set relativenumber " show the relative line number for each line

" 5 syntax, highlighting and spelling {{{2
set synmaxcol=200      " maximum column to look for syntax items
set hlsearch           " highlight all matches for the last used search pattern
set cursorline         " highlight the screen line of the cursor
if exists("&colorcolumn")
	set colorcolumn=+1 " columns to highlight
	hi! link ColorColumn CursorLine
else
	:mat ErrorMsg '\%81v.\+'
endif

" 6 multiple windows {{{2
set laststatus=2     " 0, 1 or 2; when to use a status line for the last window
set hidden           " don't unload a buffer when no longer shown in a window
set switchbuf=usetab " "useopen" and/or "split"; which window to use when jumping
set splitbelow       " a new window is put below the current one
set splitright       " a new window is put right of the current one

" 7 multiple tab pages {{{2
set showtabline=1 " 0, 1 or 2; when to use a tab pages line

" 8 terminal {{{2
set ttyfast " terminal connection is fast
set t_vb=

" 9 using the mouse {{{2
set mouse=a   " list of flags for using the mouse
set mousehide " hide the mouse pointer while typing

"10 GUI {{{2
if has('win32') || has('win32unix')
	set guifont=Consolas:h11:cANSI " list of font names to be used in the GUI
else
	set guifont=Droid\ Sans\ Mono\ 10
endif
if has("gui_running")
	" set guioptions+=P "allow visual selection to be accessed in system paste
	set guioptions+=c "use console dialogues
	set guioptions-=L "left hand toolbar isn't present
	set guioptions-=T "remove tool bar
	set guioptions-=m "remove menu bar
	set guioptions-=l "remove right scroll
	set guioptions-=r "remove left scroll
	set guioptions-=b "remove bottom scroll
endif

"11 printing {{{2

"12 messages and info {{{2
set terse        " add 's' flag in 'shortmess' (don't show search message)
set showcmd      " show (partial) command keys in the status line
set ruler        " show cursor position below each window
set novisualbell " use a visual bell instead of beeping
set noerrorbells " ring the bell for error messages

"13 selecting text {{{2

"14 editing text {{{2
set textwidth=79                     " line length above which to break a line
set wrapmargin=0                     " margin from the right in which to break a line
set backspace=eol,start,indent       " specifies what <BS>, CTRL-W, etc. can do in Insert mode
set formatoptions=tcrqln             " list of flags that tell how automatic formatting works
silent! set formatoptions+=j         " list of flags that tell how automatic formatting works
set complete=.,w,b,u,k,t             " specifies how Insert mode completion works for CTRL-N and CTRL-P
set completeopt=menu                 " whether to use a popup menu for Insert mode completion
set infercase                        " adjust case of a keyword completion match
set showmatch                        " when inserting a bracket, briefly jump to its match
set matchtime=5                      " tenth of a second to show a match for 'showmatch'
set matchpairs+=<:>                  " list of pairs that match for the "%" command

"15 tabs and indenting {{{2
set tabstop=4      " number of spaces a <Tab> in the text stands for
set shiftwidth=4   " number of spaces used for each step of (auto)indent
set smarttab       " a <Tab> in an indent inserts 'shiftwidth' spaces
set softtabstop=0  " if non-zero, number of spaces to insert for a <Tab>
set noexpandtab    " expand <Tab> to spaces in Insert mode
set autoindent     " automatically set the indent of a new line
set smartindent    " do clever autoindenting
set copyindent     " copy whitespace for indenting from previous line
set preserveindent " preserve kind of whitespace when changing indent

"16 folding {{{2
set foldtext=MyFoldText() " expression used to display the text of a closed fold
set foldminlines=0        " minimum number of screen lines for a fold to be closed
set foldmethod=marker     " folding type: "manual", "indent", "expr", "marker" or "syntax"

"17 diff mode {{{2

"18 mapping {{{2
set timeoutlen=300 " time in msec for 'timeout'

"19 reading and writing files {{{2
set modeline                        " enable using settings from modelines when reading a file
set fileformats=unix,dos,mac        " list of file formats to look for when editing a file
set noendofline                     " last line in the file has an end-of-line
set writebackup                     " write a backup file before overwriting a file
set backup                          " write a backup file before overwriting a file
set backupdir=$VIMHOME/tmp/backup// " list of directories to put backup files in
set autowrite                       " automatically write a file when leaving a modified buffer
set autoread                        " automatically read a file when it was modified outside of Vim

"20 the swap file {{{2
set directory=$VIMHOME/tmp/directory// " list of directories for the swap file
set noswapfile                         " use a swap file for this buffer

"21 command line editing {{{2
set history=700                 " how many command lines are remembered
set wildmode=full               " specifies how command line completion works
set wildignore=*.o,*~,*.pyc     " ignore case when completing file names
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.class
silent! set wildignorecase      " ignore case when completing file names
set wildmenu                    " command-line completion shows a list of matches
set cmdwinheight=3              " height of the command-line window
set undofile                    " automatically save and restore undo history
set undodir=$VIMHOME/tmp/undo// " list of directories for undo files

"22 executing external commands {{{2
if has('win32') && executable('zsh')
	set shell=C:/cygwin/bin/zsh.exe\ -i " name of the shell program used for external commands
	set shellcmdflag=-c                 " argument for 'shell' to execute a command
elseif has('win32')
	set shell=C:/cygwin/bin/bash
	set shellcmdflag=--login\ -c
	set shellxquote=\"
else
	set shell=sh
endif
set keywordprg="" " program used for the "K" command

"23 running make and jumping to errors {{{2
set makeprg=make " program used for the ":make" command

"24 system specific {{{2

"25 language specific {{{2
set isfname-==

"26 multi-byte characters {{{2
set encoding=utf-8 " character encoding used in Vim: "latin1", "utf-8"

"27 various {{{2
set virtualedit+=block " when to use virtual editing: "block", "insert" and/or "all"
set viminfo^=!         " list that specifies what to write in the viminfo file

" Make those folders if they don't already exist. " {{{
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
    call mkdir(expand(&backupdir), "p")
    call mkdir(expand(&directory), "p")
endif " }}}

" go to last cursor position when opening files
augroup line_return
	au!
	autocmd BufReadPost *
		\ if line("'\"") > 0 && line("'\"") <= line("$") |
			\ exe "normal! g'\"" |
		\ endif
augroup END

" }}}2

" FileTypes                      {{{1
"

if has("autocmd") && exists("+omnifunc")
autocmd Filetype *
		\	if &omnifunc == "" |
		\		setlocal omnifunc=syntaxcomplete#Complete |
		\	endif
endif

if has('win32') || has('win32unix')
	let dictfile="C:/cygwin/usr/share/dict/words"
else
	let dictfile="/usr/share/dict/words"
endif
augroup ft
	autocmd!
	"au FileType * exe 'setl dict+='.fnameescape($VIMRUNTIME).'/syntax/'.&filetype.'.vim'
	au Filetype * exe 'setl dict+=$VIMHOME/spell/dicts/'.&filetype.'.dict'
	autocmd BufEnter,BufNew *.tex setl ft=tex | source ~/.vim/ftplugin/tex.vim
	autocmd BufEnter,BufNew *.rout,*.Rout setl ft=r
	autocmd BufEnter,BufNew *.md setl ft=markdown
	autocmd BufEnter,BufNew README setl ft=markdown
	autocmd BufEnter,BufNew *.bible setl ft=bible
	autocmd BufEnter,BufNew three_year.txt setl ft=biblereading
	autocmd BufEnter,BufNew times.txt setl ft=times.conf
	" Remove spaces at the end of header lines when starting new mail in mutt.
	autocmd BufReadPost /tmp/*/mutt* :1,/^$/s/\s\+$//
	autocmd BufNewFile,BufRead *.mail setl filetype=mail
	autocmd BufWritePre *.vim g:noStripWhitespace
	autocmd Filetype netrw setlocal bufhidden=wipe
augroup END

augroup vimp
	autocmd!
	autocmd BufEnter pass.gpg set ft=mypass
	autocmd FileType mypass set conceallevel=2
	autocmd FileType mypass :syntax region hideup Conceal start='|' end='$'
	autocmd FileType mypass set colorcolumn=0
augroup END

" Keybindings                    {{{1
"

map <F1> :<C-U>e ~/.dotfiles/bookmarks.md<cr>
map <F2> :<C-U>e ~/Documents/Details/times.txt<cr>

" Save the current file and run the make program
map <F9>   :make<Return>
map <S-F9> :silent make<Return>

" Smart completion on tab " {{{
function! Smart_TabComplete()
	if pumvisible()
		return "\<c-n>"
	endif
	let line = getline('.')
	let substr = strpart(line, -1, col('.')+1)
	let substr = matchstr(substr, "[^ \t]*$")
	if (strlen(substr)==0)
		return "\<tab>"
	endif
	let has_period = match(substr, '\.') != -1
	let has_slash = match(substr, '\/\|\\') != -1
	if (has_slash)
		return "\<c-x>\<c-f>"
	else
		return "\<c-n>"
	endif
endfunction " }}}
inoremap <expr> <tab> Smart_TabComplete()
inoremap <s-tab> <c-p>

" TODO gf timeout
nnoremap <cr> gf

" Try using jk and kj as Escape in insert mode.
inoremap jk <Esc>
inoremap kj <Esc>

" Center search result
nnoremap n nzz
nnoremap N Nzz

nnoremap D dg_
nnoremap Y yg_

nnoremap Q :normal! n.<CR>

" Re-indent whole file
nnoremap g+ :call Preserve("normal! gg=G")<CR>

" Split lines, oposite of join, J
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" Don't change case when meaning to undo in visual mode
vnoremap u <nop>
vnoremap gu u

nnoremap ; :
nnoremap , ;

" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

" Replace selected text
vnoremap <C-r> "hy:%s/<C-r>h//g<left><left>

" Visual increment numbers
vnoremap <c-a> :norm <c-v><c-a><cr>gv
vnoremap <c-x> :norm <c-v><c-x><cr>gv

" Jump to start and end of line in insert mode
inoremap <C-a> <esc>I
inoremap <C-e> <esc>A
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" Insert current filename
inoremap <leader>fn <C-R>=expand("%:t")<CR>

" List all buffers and quickly switch to selected
nnoremap <leader>b :ls<CR>:buffer<Space>

nnoremap <leader>rc :e! $MYVIMRC<CR>
nnoremap <leader>rd :e! $VIMHOME/plugin/display.vim<CR>
augroup Reload_vimrc
	autocmd!
	autocmd BufWritePost $MYVIMRC source $MYVIMRC | echo "vimrc is sourced"
augroup END

" Fast saving
nnoremap <leader>w :w!<cr>
augroup Save
	autocmd!
	" au FocusLost * :silent! wall
	au VimResized * :wincmd =
augroup END

" Open the Tagbar sidebar
nnoremap <silent> <F8> :TagbarToggle<CR>

" Switch to Next and Previous buffer
nmap <C-n> :bnext<CR>
nmap <C-p> :bprev<CR>

" Jump to end of pasted text
vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]

" System clipboard copy and paste
nmap <leader>v "+gh
imap <leader>v <ESC>"+gpa
nmap <leader>ay ggVG"+y

" Unset highlighting of a search
nmap <silent> <leader>q :nohlsearch<CR><Plug>(clever-f-reset)

" Ranger
nnoremap <leader>r :silent !ranger %:h<cr>:redraw!<cr>
nnoremap <leader>R :silent !ranger<cr>:redraw!<cr>

" Shift-leftmouse searches for the word clicked on without moving
nnoremap <S-LeftMouse> <LeftMouse>:<C-U>let @/='\<'.expand("<cword>").'\>'<CR>:set hlsearch<CR>

"           Scroll Wheel = Up/Down 4 lines
"   Shift + Scroll Wheel = Up/Down 1 page
" Control + Scroll Wheel = Up/Down 1/2 page
noremap  <ScrollWheelUp>    6<C-Y>
noremap  <ScrollWheelDown>  6<C-E>
noremap  <S-ScrollWheelUp>   <C-Y>
noremap  <S-ScrollWheelDown> <C-E>
noremap  <C-ScrollWheelUp>   <C-U>
noremap  <C-ScrollWheelDown> <C-D>
inoremap <ScrollWheelUp>     <C-O>4<C-Y>
inoremap <ScrollWheelDown>   <C-O>4<C-E>
inoremap <S-ScrollWheelUp>   <C-O><C-Y>
inoremap <S-ScrollWheelDown> <C-O><C-E>
inoremap <C-ScrollWheelUp>   <C-O><C-U>
inoremap <C-ScrollWheelDown> <C-O><C-D>
map      <MiddleMouse>       <LeftMouse>
imap     <MiddleMouse>       <LeftMouse>
map      <2-MiddleMouse>     <LeftMouse>
imap     <2-MiddleMouse>     <LeftMouse>
map      <3-MiddleMouse>     <LeftMouse>
imap     <3-MiddleMouse>     <LeftMouse>
map      <4-MiddleMouse>     <LeftMouse>
imap     <4-MiddleMouse>     <LeftMouse>

" Increase and decrease font size in gui using Alt-Up and Alt-Down
nnoremap <A-Up> :silent! let &guifont = substitute(
 \ &guifont,
 \ ':h\zs\d\+',
 \ '\=eval(submatch(0)+1)',
 \ '')<CR><CR>
nnoremap <A-Down> :silent! let &guifont = substitute(
 \ &guifont,
 \ ':h\zs\d\+',
 \ '\=eval(submatch(0)-1)',
 \ '')<CR><CR>

" Abbreviations                  {{{1
"

cabbrev help vert help
cabbrev w!! w !sudo tee > /dev/null %

abbrev <expr> dts strftime("%d/%m/%Y")
abbrev <expr> dty strftime("%Y%m%d")
abbrev <expr> dtyd strftime("%Y-%m-%d")
abbrev <expr> dtl strftime("%c")

function! CreatedHeader()
	return "Created:  TIMESTAMP\<CR>"
		\ ."Modified: TIMESTAMP\<CR>"
		\ ."Author:   Josh Wainwright\<CR>"
		\ ."Filename: " . expand('%:t')
endfunction

iabbrev <expr> Cre: CreatedHeader()
iabbrev TST TIMESTAMP
iabbrev <expr> Weeklyr "Weekly Report<CR>
                       \=============<CR>
                       \Josh Wainwright<CR>
                       \Week ending " . system("date -d Fri '+%d/%m/%Y'") . "<CR>
                       \- <CR>
                       \<CR>
                       \Customer Site Visits<CR>
                       \--------------------<CR>
                       \<CR>
                       \Vacation<CR>
                       \--------<CR>
                       \- None"

" LDRA                           {{{1
"

augroup ldra
	autocmd!
	autocmd BufEnter,BufNew *.tcf set ft=conf
	autocmd BufEnter,BufNew *.tct set ft=conf
	autocmd BufEnter,BufNew */WeeklyReports/201* setl ft=markdown
augroup END

command! TBini :e C:\ProgramData\LDRA\TESTBED.ini

nnoremap <F11> :<C-U>e ~/Documents/Details/ldra_learnt.md<cr>
nnoremap <F12> :EditReport<cr>
nnoremap <S-F12> :EditReport!<cr>
command! -nargs=* -bang EditReport :call EditReport('<bang>' == '!', <f-args>)
function! EditReport(monthly, ...)
	let prefix = ''

	" a:0 (number of args) is >0 if a specific date is given
	if a:0 > 0
		let date = a:1
		if a:monthly
			let prefix = 'MonthlyJAW'
		endif
	" Otherwise get the relevant current date
	else
		if a:monthly
			let date = system("echo -n `date '+%Y%m'`")
			let prefix = 'MonthlyJAW'
		else
			let date = system("echo -n `date -d Fri '+%Y%m%d'`")
		endif
	endif
	let thisweek = '$HOME/Documents/Forms/WeeklyReports/'.date.prefix
	if filereadable(expand(thisweek).'.md')
		exec "edit ".thisweek.".md"
	elseif filereadable(expand(thisweek).'.txt')
		exec "edit ".thisweek.".txt"
	else
		exec "edit ".thisweek . ".md | normal iWeeklyro"
	endif
endfunction

if has("gui_running")
	set lines=40
	exe "set columns=" . (82+&numberwidth)
endif
" }}}

" vim: fdm=marker
